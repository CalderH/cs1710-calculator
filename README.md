You should write a one page README describing how you structured your model and what your model proved. You can assume that anyone reading it will be familiar with your project proposal. Here are some examples of points you might cover:
- What tradeoffs did you make in choosing your representation? What else did you try that didn’t work as well?
- What assumptions did you make about scope? What are the limits of your model?
- Did your goals change at all from your proposal? Did you realize anything you planned was unrealistic, or that anything you thought was unrealistic was doable?
- How should we understand an instance of your model and what your custom visualization shows?


One o fthe initial probelms we were haivng was figuring out how to mdel the stack of numbers that each thread manages. One way was to model it as a linked list for each thread.We thought of representing linked lists as a collection of StackFrames referencing to each other with a 'next' relation. This would make it easy to find thigns like the top most stack frame, or the stack frame that comes after another one. However, it becasme hard to manage multithreaded environmnts because StackFrames did not explicitly have a field for which threads they were a part of; the only way to tell which thread a frame was a part of was to find which thread was associated with the *end* frame connected to this frame. The "next" operation was shared among all the threads, so it was hard to find which "next" tuples belonged to which stack. Also, if every element in every stack requires a StackFrame atom, we would have to know beforehand how many StackFrames need to be in the bounds, and we would have to recycle unused StackFrames to be used in new stacks.

So, we decided to sinstead represnet thread stacks using indexes Int relations. This makes it easier to to tell which stack belongs to each thread, makes it eeasier to access specific poitns into the stack (since we can jsut use direct Ins now isntead of tracing next multiple times), and means that we do not need to keep track of separate StackFrame objects for every item in the stack. The only turnoff is that we would have to deal with the "nasty" Forge arithmetic syntax for all of our stack logic. However, this allowed us to achieve pretty clean stack manipultoin logic since we can more easily refer to any point in the stack with just their indices.

We had to make a similar decision between an indexed array and a linked list for the list of operations, as well. Choosing an indexed array made it easy to add control flow operations that can make a thread jump to an arbitrary point in the operations list.

In our proposal, we expected that we would be able to provide a set of example inputs and outputs, and let Forge search for a sequence of operations (a function) that maps those inputs to those outputs. For simple operations, this worked: for example, the model was able to construct the function “f(x) = x * (x + 1)” from a few input/output pairs. We had also hoped to do this with more complicated functions; in particular, we wondered what conditions would cause the model to find programs that are simply a table of “if”s rather than functions that actually manipulate the inputs. However, it ends up being that even a simple if-table requries too many operations to run in any reasonable amount of time. We had also hoped to try more complicated functions like prime factorization, but decided not to try this when we found that even a simple absolute value function took about 20 minutes to run on 5 inputs (i.e., 5 threads, each with a different starting value).

